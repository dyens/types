* –ó–∞—á–µ–º
- –¥–æ–ø –ø—Ä–æ–≤–µ—Ä–∫–∏ (+1 –∫—Ä—É—Ç–æ–π –ª–∏–Ω—Ç–µ—Ä)
  —Å–µ–±—è + –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è –∫–æ–¥–∞ –≤ –∫–æ–º–∞–Ω–¥–µ
  –±—ã—Å—Ç—Ä—ã–π –ø–æ–∏—Å–∫ –æ—à–∏–±–æ–∫, –Ω–µ –Ω–∞–¥–æ –∑–∞–ø—É—Å–∫–∞—Ç—å –ø—Ä–æ–≥—Ä–∞–º–º—É, –¥–µ–ø–ª–æ–∏—Ç—å –∏ —Ç–¥..
- –û—Ç–º–µ–Ω–∞ —Ç–µ—Å—Ç–æ–≤ –ø—Ä–æ–≤–µ—Ä–∫–∏ —Ç–∏–ø–æ–≤
- –í—Å–µ –∏—Å–ø–æ–ª—å–∑—É—é—Ç, –Ω–∞–¥–æ —É—á–∏—Ç—å—Å—è —Å —ç—Ç–∏–º –∂–∏—Ç—å
- –î–æ–∫—É–º–µ–Ω–∏—Ç—Ä–æ–≤–∞–Ω–∏–µ —Å–∏–≥–Ω–∞—Ç—É—Ä
- –ü–æ–º–æ—â—å –≤ —Ä–µ–¥–∞–∫—Ç–æ—Ä–µ
- –†–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥

* –ü—Ä–∏–º–µ—Ä
#+begin_src mypy
def moon_weight(earth_weight: float) -> str:
    return f'On the moon, you would weigh {earth_weight * 0.166} kilograms.'

some_int: int
some_string: str = "this is string"
#+end_src

* from __future__ import annotations
#+begin_src python
def func(x: "MyType"): ...

class MyType: ...

#+end_src

If from __future__ import annotations is used, annotations are not
evaluated at function definition time. Instead, they are stored as
strings in __annotations__. This makes it unnecessary to use quotes
around the annotation 

* Simple types

#+begin_src mypy
x: int = 1
x: float = 1.0
x: bool = True
x: str = "test"
x: bytes = b"test"
#+end_src

* Containers

–ß–µ–º tuple –æ—Ç–ª–∏—á–∞–µ—Ç—Å—è –æ—Ç list ?
#+begin_src mypy


list[int] = [1,2,3]
tuple[int, float, str] = (0, 0.3, "a")


# For collections on Python 3.9+, the type of the collection item is in brackets
x: list[int] = [1]
x: set[int] = {6, 7}

# For mappings, we need the types of both keys and values
x: dict[str, float] = {"field": 2.0}  # Python 3.9+

# For tuples of fixed size, we specify the types of all the elements
x: tuple[int, str, float] = (3, "yes", 7.5)  # Python 3.9+

# For tuples of variable size, we use one type and ellipsis
x: tuple[int, ...] = (1, 2, 3)  # Python 3.9+
x: tuple[int, ...] = (1, "a", 3)  # –û—à–∏–±–∫–∞

# On Python 3.8 and earlier, the name of the collection type is
# capitalized, and the type is imported from the 'typing' module
from typing import List, Set, Dict, Tuple
x1: List[int] = [1]
x2: Set[int] = {6, 7}
x3: Dict[str, float] = {"field": 2.0}
x4: Tuple[int, str, float] = (3, "yes", 7.5)
x5: Tuple[int, ...] = (1, 2, 3)
#+end_src

* Any
–°–æ–≤–º–µ—Å—Ç–∏–º —Å –ª—é–±—ã–º —Ç–∏–ø–æ–º –∏ –ª—é–±–æ–π —Ç–∏–º —Å–æ–≤–º–µ—Å—Ç–∏–º —Å Any
#+begin_src mypy
from typing import Any

a: Any = None
a = []
a = 2

s: str = ''
s = a # –í–Ω–∏–º–∞–Ω–∏–µ !

def foo(item: Any) -> int:
    item.bar()
    return 3
#+end_src

–õ—é–±–æ–π —Ç–∏–ø —è–≤–ª—è–µ—Ç—Å—è –ø–æ—Ç–æ–º–∫–æ–º object –∏ Any, –Ω–æ –æ–±—Ä–∞—Ç–Ω–æ –Ω–µ–≤–µ—Ä–Ω–æ - –≤–æ—Ç–ª–∏—á–∏–∏ –æ—Ç Any object –Ω–µ —è–≤–ª—è–µ—Ç—Å—è –ø–æ–¥—Ç–∏–ø–æ–º
–ª—é–±–æ–≥–æ –¥—Ä—É–≥–æ–≥–æ —Ç–∏–ø–∞.

#+begin_src mypy
from typing import Any

def hash_a(item: object) -> int:
    # Fails type checking; an object does not have a 'magic' method.
    item.magic()
    return 1

def hash_b(item: Any) -> int:
    item.magic()
    return 1

# Passes type checking, since ints and strs are subclasses of object
hash_a(42)
hash_a("foo")

# Passes type checking, since Any is compatible with all types
hash_b(42)
hash_b("foo")
#+end_src

#+RESULTS:
: /tmp/babel-VWgyKs/mypy-VQlhFZ:5: error: "object" has no attribute "magic"  [attr-defined]
: Found 1 error in 1 file (checked 1 source file)

* Union
#+begin_src mypy
from typing import Union

# On Python 3.10+, use the | operator when something could be one of a few types
x1: list[int | str] = [3, 5, "test", "fun"]  # Python 3.10+
# On earlier versions, use Union
x2: list[Union[int, str]] = [3, 5, "test", "fun"]
#+end_src


#+begin_src mypy

# The arguments must be types and there must be at least one.
# Unions of unions are flattened, e.g.:
Union[Union[int, str], float] == Union[int, str, float]

# Unions of a single argument vanish, e.g.:
Union[int] == int  # The constructor actually returns int

# Redundant arguments are skipped, e.g.:
Union[int, str, int] == Union[int, str] == int | str

# When comparing unions, the argument order is ignored, e.g.:
Union[int, str] == Union[str, int]

# You cannot subclass or instantiate a Union.
# You cannot write Union[X][Y].
#+end_src

* Optional
#+begin_src mypy
from typing import Optional

def some_condition() -> bool:
    return True

# Use Optional[X] for a value that could be None
# Optional[X] is the same as X | None or Union[X, None]
x: Optional[str] = "something" if some_condition() else None
if x is not None:
    # Mypy understands x won't be None here because of the if-statement
    print(x.upper())
# If you know a value can never be None due to some logic that mypy doesn't
# understand, use an assert
assert x is not None
print(x.upper())
#+end_src

* Type aliases
–î–ª—è –Ω–∞–¥–µ–ª–µ–Ω–∏—è —Ñ–∏–∑–∏—á–µ—Å–∫–∏–º —Å–º—ã—Å–ª–æ–º —Ç–∏–ø–æ–≤.
–£–¥–æ–±–Ω–æ –¥–ª—è –æ–ø–∏—Å–∞–Ω–∏—è —Å–ª–æ–∂–Ω—ã—Ö —Ç–∏–ø–æ–≤.

https://docs.python.org/3/reference/simple_stmts.html#type
–ù—É–∂–Ω–æ pip install mypy-dev

typing.TypeAlias - deprecated 3.12, –Ω—É–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å type ü§£

#+begin_src mypy
type Vector = list[float] # python3.12, mypy1.11

from typing import TypeAlias # python3.11
Vector2: TypeAlias = list[float]

# From doc:
# The type statement is new in Python 3.12. For backwards compatibility,
# type aliases can also be created through simple assignment:
Vector3 = list[float]
# –í—Ä—è–¥–ª–∏ —Ç–∞–∫–æ–µ —Å–¥–µ–ª–∞—é—Ç deprecated –≤ –±–ª–∏–∂–∞–π—à–µ–µ –≤—Ä–µ–º—è...

def scale(scalar: float, vector: Vector) -> Vector:
    return [scalar * num for num in vector]
#+end_src

–ù–æ —á—Ç–æ —Ç–∞–∫–æ–µ =list[float]=?

#+begin_src python :results output
# SANDBOX
a = list[str]
print(a, type(a))

#from types import GenericAlias
# https://docs.python.org/3/library/types.html#types.GenericAlias
# Changed in version 3.9.2: This type can now be subclassed.
x = a([1,2,3])
print(x)
#+end_src

#+RESULTS:
: list[str] <class 'types.GenericAlias'>
: [1, 2, 3]

* New type

#+begin_src python :results output
from typing import NewType

# y = NewType(x, int); –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å y == x
UserId = NewType('UserId', int)
some_id = UserId(524313)

print(some_id, type(UserId), type(some_id))
#+end_src

#+RESULTS:
: 524313 <class 'typing.NewType'> <class 'int'>

–ù–æ –∑–∞—á–µ–º —ç—Ç–æ –Ω—É–∂–Ω–æ –∏ —á–µ–º —ç—Ç–æ –¥–ª—è –Ω–∞—Å –æ—Ç–ª–∏—á–∞–µ—Ç—Å—è –æ—Ç TypeAlias ???
–ö–∞–∫ –≤—ã –¥—É–º–∞–µ—Ç–µ, —á—Ç–æ –≤–µ—Ä–Ω–µ—Ç –∑–¥–µ—Å—å print ?

#+begin_src python :results output
from typing import NewType

class A:
    def __init__(self, v):
        self._v = v
        print(v)

UserId = NewType('UserId', A)

uid = UserId(3)
print(type(uid))

def func(v: UserId):
    v.val 



class UserId:
   val: int

func(UserId(3))

#+end_src

#+RESULTS:
: <class 'int'>

https://docs.python.org/3/library/typing.html#newtype

* TypeVarTuple, Unpack

TypeVarTuple —ç—Ç–æ –∫–∞–∫ –æ–±–æ–±—â–µ–Ω–Ω—ã–π —Ç–∏–ø –≤—Ä–æ–¥–µ tuple[T1, T2, T3, ...]

#+begin_src mypy
from typing import TypeVar, TypeVarTuple, Unpack

T = TypeVar("T")
Ts = TypeVarTuple("Ts")


def move_first_element_to_last(tup: tuple[T, Unpack[Ts]]) -> tuple[Unpack[Ts], T]:
    return (*tup[1:], tup[0])


def move_first_element_to_last2(tup: tuple[T, *Ts]) -> tuple[*Ts, T]:
    return (*tup[1:], tup[0])


move_first_element_to_last(tup=(1,))
move_first_element_to_last(tup=(1, 'spam'))
move_first_element_to_last(tup=(1, 'spam', 3.0))
move_first_element_to_last(tup=()) # –¢—É—Ç –æ—à–∏–±–∫–∞! –æ–¥–∏–Ω –ø–∞—Ä–∞–º–µ—Ç—Ä –Ω–µ–æ–±—Ö–æ–¥–∏–º.
#+end_src

TypeVarTuple –≤—Å–µ–≥–¥–∞ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è —Å Unpack
#+begin_src mypy
x: Ts          # Not valid
x: tuple[Ts]   # Not valid
x: tuple[*Ts]  # The correct way to do it
#+end_src

–ú–æ–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∫–∞–∫ generic –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –≤ –∫–ª–∞—Å—Å–∞—Ö:

#+begin_src mypy
class Array[DType, *Shape]:
    def __init__(self, shape: tuple[*Shape], dtype: DType):
        self._shape = shape
        self._dtype = dtype

    def __getitem__(self, key: tuple[*Shape]) -> float:
        return 0.1

    def __abs__(self) -> "Array[DType, *Shape]":
        return self

    def get_shape(self) -> tuple[*Shape]:
        return self._shape
#+end_src

–ú–æ–∂–Ω–æ –≤ Callable:

#+begin_src mypy
from typing import Callable

def call_soon[*Ts](
    callback: Callable[[*Ts], None],
    *args: *Ts,
) -> None:
    callback(*args)
#+end_src

#+RESULTS:
: Success: no issues found in 1 source file

* collections.abc
[[file:~/.local/share/mise/installs/python/3.12/lib/python3.12/_collections_abc.py::class Hashable(metaclass=ABCMeta):][collections.abc]]
https://docs.python.org/3/library/collections.abc.html
–•–æ—Ä–æ—à–æ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã —Ñ—É–Ω–∫—Ü–∏–∏ –¥–µ–ª–∞—Ç—å –∫–∞–∫ –º–æ–∂–Ω–æ –±–æ–ª–µ–µ –æ–±—â–∏–º–∏ —Ç–∏–ø–∞–º–∏, –∞ –≤–æ–∑–≤—Ä–∞—â–∞—é—â–µ–µ –∑–Ω–∞—á–µ–Ω–µ–µ –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–º

#+begin_src mypy
async def func(x: int) -> str:
    return "a"

reveal_type(func)
#+end_src

#+RESULTS:
: /tmp/babel-tLYvnr/mypy-4SNXXI:4: note: Revealed type is "def (x: builtins.int) -> typing.Coroutine[Any, Any, builtins.str]"
: Success: no issues found in 1 source file

#+begin_src mypy
from collections.abc import Reversible

# –ø–ª–æ—Ö–æ
def f(x: list[int]) -> list[int]:
    return list(reversed(x))


# —Ö–æ—Ä–æ—à–æ
def f2(x: Reversible[int]) -> list[int]:
    return list(reversed(x))
#+end_src

Nominal vs structural (static duck typing) subtyping

#+begin_src mypy

from collections.abc import Sized, Iterable, Iterator

def collect(items: Iterable[int]) -> int: ...

# Nominal
class Bucket(Sized, Iterable[int]):
    ...
    def __len__(self) -> int: ...
    def __iter__(self) -> Iterator[int]: ...

from collections.abc import Iterator, Iterable

# Structural
class Bucket:  # Note: no base classes
    ...
    def __len__(self) -> int: ...
    def __iter__(self) -> Iterator[int]: ...

result = collect(Bucket())  # Passes type check
#+end_src



–£–∑–Ω–∞–ª –ø—Ä–æ —Ñ–æ—Ä–º—É iter(callable, sentinel):
#+begin_src python :results output
a = list(1, 2, 3)

for i in a:
    do(i)
    
iterator = iter(a)

while True:
    try:
        val = next(iterator)
        do(val)
    except StopIteration:
        break


c = 0

def f():
    global c
    c += 1
    return c


for i in iter(f, 3):
    print(i)
#+end_src

#+RESULTS:
: 1
: 2

–ú–æ–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å =__getitem__= –¥–ª—è –æ–ø–∏—Å–∞–Ω–∏—è iterable
#+begin_src python :results output
class IT:
    d = [0, 1]

    def __getitem__(self, k):
        return self.d[k]


for i in IT():
    print(i)
#+end_src

#+RESULTS:
: 0
: 1

* Type or class objects
=type= - covariant

#+begin_src mypy
from typing import Type # DEPRECATED
a = 3         # Has type ``int``
b = int       # Has type ``type[int]``
c = type(a)   # Also has type ``type[int]``


class User: ...
class ProUser(User): ...
class TeamUser(User): ...

def make_new_user(user_class: type[User]) -> User:
    # ...
    return user_class()

make_new_user(User)      # OK
make_new_user(ProUser)   # Also OK: ``type[ProUser]`` is a subtype of ``type[User]``
make_new_user(TeamUser)  # Still fine
make_new_user(User())    # Error: expected ``type[User]`` but got ``User``
make_new_user(int)       # Error: ``type[int]`` is not a subtype of ``type[User]``

# –ú–æ–∂–Ω–æ class, Any, TypeVar
type[Any] == type
#+end_src

* Generics

TypeVar - –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è –¥–ª—è —Ç–∏–ø–∞. –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –≤ generic functions, generic classes, generic type aliases

–°–∏–≥–Ω–∞—Ç—É—Ä–∞:
#+begin_src python
class typing.TypeVar(name, *constraints, bound=None, covariant=False, contravariant=False, infer_variance=False)
# –ú–æ–∂–Ω–æ –≤—ã–±—Ä–∞—Ç—å —Ç–æ–ª—å–∫–æ –ª–∏–±–æ covariant –ª–∏–±–æ contravariant –ø–æ –¥–µ—Ñ–æ–ª—Ç—É invariant
#+end_src

** Invariant, Covariant, Contravariant

#+begin_src mypy

class Base:
    ...

class Child(Base):
    ...

# Child - –ø–æ–¥—Ç–∏–ø, –ø–æ—Ç–æ–º—É —á—Ç–æ –º—ã –º–æ–∂–µ–º –µ–≥–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –≥–¥–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è Base

def func(v: Base): ...

func(Child())
#+end_src

#+begin_src python
from typing import TypeVar

class Fruit:
    def eat(self) -> None:
        return "Eat fruit"

class Apple(Fruit):
    def apple_class(self) -> str:
        return "—Ä–∞–Ω–µ—Ç–∫–∞"


T = TypeVar("T", bound=Fruit)

class JuceMaker(Generic[T]):
    ...

# –ï—Å–ª–∏ Fruit -> Apple, —Ç–æ –∫–∞–∫ —Å–æ–æ—Ç–Ω–æ—Å–∏—Ç—Å—è JuceMaker[Fruit] ?? JuceMaker[Apple] ?

# –ü—Ä–∏–º–µ—Ä T - –∫–æ–≤–∞—Ä–∏–∞–Ω—Ç–Ω–∞—è –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è
class Storage(Generic[T]):
    def get(self) -> T:
        return T()

def f(v: Storage[Fruit]):
    x: Fruit = v.get()
    x.eat()
    
def f(v: Storage[Apple]):
    x: Fruit = v.get()
    x.eat() # Apple –º—ã –º–æ–∂–µ–º –µ—Å—Ç—å !!!
 
# –ü—Ä–∏–º–µ—Ä T - –∫–æ–Ω—Ç—Ä–∞–≤–∞—Ä–∏–∞–Ω—Ç–Ω–∞—è –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è
class JuceMaker(Generic[T]):
    def make(self, value: T):
        print("–¥–µ–ª–∞–µ–º —Å–æ–∫")
        self._v = value

def f(v: JuceMaker[Fruit]):
    v.make(Fruit())
    
def f(v: JuceMaker[Apple]):
    v.make(Fruit()) # –æ—à–∏–±–∫–∞ JuceMaker.make -—Ñ—É–Ω–∫—Ü–∏—è –æ–∂–∏–¥–∞–µ—Ç Apple, –∞ –º—ã –ø–µ—Ä–µ–¥–∞–µ–º Fruit
 
# –ü—Ä–æ–≤–µ—Ä–∏–º –æ–±—Ä–∞—Ç–Ω–æ–µ —Å–æ–æ—Ç–Ω–æ—à–µ–Ω–∏–µ:

def f(v: JuceMaker[Apple]):
    v.make(Apple())
    
def f(v: JuceMaker[Fruit]):
    v.make(Apple()) # –ê —Ç—É—Ç –≤—Å–µ —Ö–æ—Ä–æ—à–æ
 

# –ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ —Ç–∏–ø–æ–≤, –∫–æ—Ç–æ—Ä—ã–µ –∏—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è –∫–∞–∫ –∞—Ä–≥—É–º–µ–Ω—Ç—ã —Ñ—É–Ω–∫—Ü–∏–∏ - –∫–æ–Ω—Ç—Ä–∞–≤–∞—Ä–∏–∞–Ω—Ç–Ω—ã–µ
# –ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ, –∫–æ—Ç–æ—Ä—ã–µ –∏—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è –∫–∞–∫ —Ä–µ–∑—É–ª—å—Ç–∞—Ç - –∫–æ–≤–∞—Ä–∏–∞–Ω—Ç–Ω—ã–µ

# list - –∏–Ω–≤–∞—Ä–∏–∞–Ω—Ç–Ω—ã–π, frozen_list - –∫–æ–≤–∞—Ä–∏–∞–Ω—Ç–Ω—ã–π
#+end_src

infer_variance - –ø–æ–∑–≤–æ–ª—è–µ—Ç —Å–∏—Å—Ç–µ–º–µ —Ç–∏–ø–æ–≤ —Å–∞–º–æ–π –≤—ã–≤–æ–¥–∏—Ç—å –Ω—É–∂–Ω—É—é –≤–∞—Ä–∏–∞–Ω—Ç–Ω–æ—Å—Ç—å 
https://peps.python.org/pep-0695/#variance-inference

** –ü—Ä–∏–º–µ—Ä—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è TypeVar
#+begin_src mypy
from collections.abc import Sequence
from typing import TypeVar

U = TypeVar('U')

def second(l: Sequence[U]) -> U:
    return l[1]

# New python:
from collections.abc import Sequence

def first[T](l: Sequence[T]) -> T:
    return l[0]

def first[S: str](l: Sequence[S]) -> S:
    return l[0]

def first[A: (str, bytes)](l: Sequence[A]) -> A:
    return l[0]

# –≠—Ç–æ –∞–Ω–∞–ª–∞–≥–∏—á–Ω–æ

T = TypeVar('T')  # Can be anything
S = TypeVar('S', bound=str)  # Can be any subtype of str
A = TypeVar('A', str, bytes)  # Must be exactly str or bytes
#+end_src


#+begin_src mypy
from typing import Generic, TypeVar

T = TypeVar("T")

class Container(Generic[T]):

    _value: T

    def __init__(self, value: T) -> None:
        self._value = value

    def get(self) -> T:
        return self._value

c = Container(3)
v: int = c.get()

c2 = Container[str]("hello")
v2: str = c2.get()

print(Container.__class_getitem__(str))
#+end_src

–†–∞–±–æ—Ç–∞–µ—Ç —Ç–æ–ª—å–∫–æ —Å mypy-dev + " --enable-incomplete-feature=NewGenericSyntax"

#+begin_src mypy
from typing import Generic

class Container[T]:
    _value: T

    def __init__(self, value: T) -> None:
        self._value = value

    def get(self) -> T:
        return self._value
#+end_src

–ù–æ–≤—ã–π —Å–∏–Ω—Ç–∞–∫—Å–∏—Å —Å–∞–º –≤—ã–≤–æ–¥–∏—Ç –≤–∞—Ä–∏–∞–Ω—Ç–Ω–æ—Å—Ç—å
#+begin_src mypy
from typing import TypeVar, Generic, Sequence

class WeirdTrio[T, B: Sequence[bytes], S: (int, str)]:
    ...

OldT = TypeVar('OldT', contravariant=True)
OldB = TypeVar('OldB', bound=Sequence[bytes], covariant=True)
OldS = TypeVar('OldS', int, str)

class OldWeirdTrio(Generic[OldT, OldB, OldS]):
    ...
#+end_src

typevar –º–æ–∂–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è –ø—Ä–∏ –Ω–∞—Å–ª–µ–¥–æ–≤–∞–Ω–∏–∏
#+begin_src mypy
from collections.abc import Mapping

class MyDict[T](Mapping[str, T]):
    ...
#+end_src

–ë–µ–∑ —É–∫–∞–∑–∞–Ω–∏—è type parameter - –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è Any
#+begin_src mypy
from collections.abc import Iterable

class MyIterable(Iterable): # Same as Iterable[Any]
    ...
#+end_src

* Callable

#+begin_src mypy
from collections.abc import Callable # from typing import Callable is deprecated, use linters

f: Callable[[], str]
f2: Callable[[int, float], str]
f3: Callable[..., str]
#+end_src

–ù–æ —Ñ—É–Ω–∫—Ü–∏–∏ –ø–æ—Å–ª–æ–∂–Ω–µ–µ –≤—ã–≥–ª—è–¥—è—Ç. –ú–æ–∂–Ω–æ —Ç–∞–∫:

#+begin_src mypy

# This feature is deprecated. You can use callback protocols as a replacement.
from typing import Callable
from mypy_extensions import (Arg, DefaultArg, NamedArg,
                             DefaultNamedArg, VarArg, KwArg)

def func(__a: int,  # This convention is for nameless arguments
         b: int,
         c: int = 0,
         *args: int,
         d: int,
         e: int = 0,
         **kwargs: int) -> int:
    return 3

F = Callable[[int,  # Or Arg(int)
              Arg(int, 'b'),
              DefaultArg(int, 'c'),
              VarArg(int),
              NamedArg(int, 'd'),
              DefaultNamedArg(int, 'e'),
              KwArg(int)],
             int]

f: F = func
#+end_src

–ê –µ—Å—Ç—å –µ—â–µ (—Å —ç—Ç–∏–º –≤–æ–æ–±—â–µ –Ω–µ —è—Å–Ω–æ –∫–∞–∫ –±—ã—Ç—å —Å Callable):

#+begin_src python
def f(a, b, /, c, *, d, e):
    pass
#+end_src

* ParamSpec
#+begin_src mypy
from typing import Callable, ParamSpec, TypeVar

P = ParamSpec("P")
T = TypeVar("T")


def decorator(f: Callable[P, T]) -> Callable[P, T]:
    def inner(*args: P.args, **kwargs: P.kwargs) -> T:
        print("Called with", args, kwargs)
        return f(*args, **kwargs)
    return inner


@decorator
def my_func(x: int, y: str) -> str:
    return y * x
#+end_src

–ï—Å–ª–∏ –≤ —Å–ø–∏—Å–∫–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö **P - —Ç–æ —ç—Ç–æ ParamSpec:

#+begin_src mypy
type IntFunc[**P] = Callable[P, int]

def decorator[T, **P](f: Callable[P, T]) -> Callable[P, T]:
    def inner(*args: P.args, **kwargs: P.kwargs) -> T:
        print("Called with", args, kwargs)
        return f(*args, **kwargs)
    return inner
#+end_src

–ú–æ–∂–µ—Ç bound, covariant, contravariant
–ù–æ —ç—Ç–æ –≤—ã–≥–ª—è–¥–∏—Ç –∫–∞–∫ –æ—à–∏–±–∫–∞, –Ω–µ—Ç –≤–º–µ–Ω—è–µ–º—ã—Ö –ø—Ä–∏—á–∏–Ω –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —ç—Ç–æ:
https://github.com/python/typing/issues/1027
–¢–∞–∫ –∫–∞–∫ —ç—Ç–æ —É–∂–µ –µ—Å—Ç—å –≤ –ø–∏—Ç–æ–Ω–µ –∏ –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç –≤ runtime, –≤–∏–¥–∏–º–æ —ç—Ç–æ –Ω–µ —É–±–µ—Ä—É—Ç.
–•–æ—Ç—è –º–± –ø—Ä–∏–¥—É–º–∞—é—Ç –∫–∞–∫–∏–µ —Ç–æ –≤–∞—Ä–∏–∞–Ω—Ç—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è —ç—Ç–æ–≥–æ...

–ï—Å—Ç—å –µ—â–µ —Ç–∞–∫–æ–π —Ç—Ä—é–∫ü´£ :

#+begin_src mypy
import time
from contextlib import contextmanager
from typing import Any, Callable


@contextmanager
def timing():
    try:
        start = time.time()
        yield
        end = time.time()
    finally:
        print("timing: ", end - start)


@timing()
def f(x: int, *, g: Callable[..., int]) -> float:
    g()
    return 1.1


r = f(1, g=lambda: 3)
assert r == 1.1
reveal_type(f)
#+end_src

#+RESULTS:
: /tmp/babel-VWgyKs/mypy-XNwE24:24: note: Revealed type is "def (x: builtins.int, *, g: def (*Any, **Any) -> builtins.int) -> builtins.float"
: Success: no issues found in 1 source file

* Concatenate

Callable[[Concatenate[int P]], R]

#+begin_src mypy
from collections.abc import Callable
from threading import Lock
from typing import Concatenate

my_lock = Lock()

def with_lock[**P, R](f: Callable[Concatenate[Lock, P], R]) -> Callable[P, R]:
    def inner(*args: P.args, **kwargs: P.kwargs) -> R:
        return f(my_lock, *args, **kwargs)
    return inner

@with_lock
def sum_threadsafe(lock: Lock, numbers: list[float]) -> float:
    with lock:
        return sum(numbers)

sum_threadsafe([1.1, 2.2, 3.3])
#+end_src

* –°–ª–æ–∂–Ω—ã–µ —Ç–∏–ø—ã
** –°—Ç—Ä—É–∫—Ç—É—Ä—ã
#+begin_src mypy
from typing import ClassVar

class Point:

    x: float
    y: float
    version: ClassVar[str] = "0.0.1"

    def __init__(self, x: float, y: float) -> None:
        self.x = x
        self.y = y
#+end_src


–ü–æ –ø–∞–º—è—Ç–∏ –≤—ã–≥–æ–¥–Ω–æ –æ–±—å—è–≤–ª—è—Ç—å –∞—Ç—Ç—Ä–∏–±—É—Ç—ã –∏–º–µ–Ω–Ω–æ –≤ =__init__=.
–•–æ—Ä–æ—à–∞—è –∏–¥–µ—è –æ–±—å—è–≤–∏—Ç—å —Ç–∏–ø—ã –æ–±—å–µ–∫—Ç–∞.
–ù–æ –µ—Å–ª–∏ –µ—Å—Ç—å –ø—Ä–∏—Å–≤–∞–∏–≤–∞–Ω–∏–µ, —Ç–æ —ç—Ç–æ —É–∂–µ ClassVar

** –û–±—å–µ–∫—Ç—ã
#+begin_src mypy
class Point:

    def __init__(self, x: float, y: float) -> None:
        self._x = x
        self._y = y

    @classmethod
    def from_r_phi(cls, r: float, phi: float) -> None:
        ...

    def move(self, direction: Vector2D) -> Point:
        ...
#+end_src

–ö–æ–≥–¥–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å =__=, =_= ?

** from typing import NamedTuple
–ï—Å—Ç—å —Ä–∞—Å–ø–∞–∫–æ–≤–∫–∞ - –Ω–æ –Ω–∏–∫–æ–≥–¥–∞ —ç—Ç–æ –Ω–µ –Ω–∞–¥–æ (=__iter__=).
–õ—É—á—à–µ –≤—Å–µ–≥–¥–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å dataclass (frozen, slots) - –∑–∞–Ω–∏–º–∞–µ—Ç –º–µ–Ω—å—à–µ –ø–∞–º—è—Ç–∏
–í–æ–æ–±—â–µ —ç—Ç–æ –ø—Ä–∏–¥—É–º–∞–Ω–æ –¥–ª—è –æ–ø–∏—Å–∞–Ω–∏—è —Ç–∏–ø–æ–≤ –º–Ω–µ –∫–∞–∂–µ—Ç—Å—è –Ω–µ —Å—Ç–æ–∏—Ç –∏–Ω—Å—Ç–∞–Ω—Ü–∏—Ä–æ–≤–∞—Ç—å —Ç–∞–∫–∏–µ –∫–ª–∞—Å—Å—ã
** from typing import TypedDict
–£–¥–æ–±–Ω–æ –∫–æ–≥–¥–∞ –ø—Ä–∏—Ö–æ–¥–∏—Ç –∫–∞–∫–æ–π —Ç–æ json
–í–æ–æ–±—â–µ —ç—Ç–æ –ø—Ä–∏–¥—É–º–∞–Ω–æ –¥–ª—è –æ–ø–∏—Å–∞–Ω–∏—è —Ç–∏–ø–æ–≤ –º–Ω–µ –∫–∞–∂–µ—Ç—Å—è –Ω–µ —Å—Ç–æ–∏—Ç –∏–Ω—Å—Ç–∞–Ω—Ü–∏—Ä–æ–≤–∞—Ç—å —Ç–∞–∫–∏–µ –∫–ª–∞—Å—Å—ã
#+begin_src mypy
from typing import TypedDict
import json

class Data(TypedDict):
    name: str
    age: int

data: Data = json.load(open("my_file"))
assert data["name"] == "aaa"
#+end_src
** from dataclasses import dataclass
** from pydantic import BaseModel
* –ò–Ω—Ç–µ—Ä—Ñ–µ–π—Å, –∞–±—Å—Ç—Ä–∞–∫—Ç–Ω—ã–π –∫–ª–∞—Å—Å, Protocol
interface - full abstract class
protocol - –Ω–µ —è–≤–Ω—ã–π interface

–ö–∞–∫ –ª—É—á—à–µ –ø–∏—Å–∞—Ç—å ?
#+begin_src mypy
from typing import Protocol

class A(Protocol):
    def m1(self):
        ...

    def m2(self):
        pass

    def m3(self):
        raise NotImplementedError

    def m4(self):
        "This is m4 method."
#+end_src

The following protocols are provided by the typing module. All are decorated with @runtime_checkable.

class typing.SupportsAbs
    An ABC with one abstract method __abs__ that is covariant in its return type.

class typing.SupportsBytes
    An ABC with one abstract method __bytes__.

class typing.SupportsComplex
    An ABC with one abstract method __complex__.

class typing.SupportsFloat
    An ABC with one abstract method __float__.

class typing.SupportsIndex
    An ABC with one abstract method __index__.

class typing.SupportsInt
    An ABC with one abstract method __int__.

class typing.SupportsRound
    An ABC with one abstract method __round__ that is covariant in its return type.

class typing.IO
class typing.TextIO
class typing.BinaryIO

Generic type IO[AnyStr] and its subclasses TextIO(IO[str]) and BinaryIO(IO[bytes]) represent 

* runtime_checkable
#+begin_src mypy
from typing import runtime_checkable

@runtime_checkable
class Closable(Protocol):
    def close(self): ...

assert isinstance(open('/some/file'), Closable)

@runtime_checkable
class Named(Protocol):
    name: str

import threading
assert isinstance(threading.Thread(name='Bob'), Named)
#+end_src

* AnyStr
–°–æ–º–Ω–∏—Ç–µ–ª—å–Ω–æ, –Ω–æ –æ–∫
#+begin_src mypy
AnyStr = TypeVar('AnyStr', str, bytes)
#+end_src

* LiteralString
–ö–º–∫ —Ç–æ–∂–µ —Ä–µ–¥–∫–æ –ø—Ä–∏–µ–Ω–∏–º. –ù—É –≤–æ—Ç —Å DB query —Ö–æ—Ä–æ—à–∏–π –∫–µ–π—Å. –í –æ—Å—Ç–∞–ª—å–Ω—ã—Ö —Å–ª—É—á–∞—è—Ö, –µ—Å–ª–∏ –Ω—É–∂–Ω–∞ –ø—Ä–æ—Å—Ç–æ
–∫–æ–Ω—Å—Ç–∞–Ω—Ç–∞ Final, Literal["abc"], –∞ –¥–ª—è –∞—Ä–≥—É–º–µ–Ω—Ç–∞ —Ñ—É–Ω–∫—Ü–∏–∏ –æ–±—ã—á–Ω—ã–π str, AnyStr.

#+begin_src mypy
def run_query(sql: LiteralString) -> None:
    ...

def caller(arbitrary_string: str, literal_string: LiteralString) -> None:
    run_query("SELECT * FROM students")  # OK
    run_query(literal_string)  # OK
    run_query("SELECT * FROM " + literal_string)  # OK
    run_query(arbitrary_string)  # type checker error
    run_query(  # type checker error
        f"SELECT * FROM students WHERE name = {arbitrary_string}"
    )
#+end_src

* NoReturn Never
#+begin_src mypy
from typing import NoReturn

def exc() -> NoReturn:
    raise RuntimeError()

from typing import Never
import enum

def assert_never(_: Never) -> Never:
    raise AssertionError("This code is unreachable")

class CPUInstruction(enum.Enum):
    ADD = "add"
    MOVE = "move"

def execute(instruction: CPUInstruction) -> None:
    match instruction:
        case CPUInstruction.ADD:
            print("ADD")
        case CPUInstruction.MOVE:
            print("MOVE")
        case _:
            assert_never(instruction)
#+end_src

–ï—Å—Ç—å –≤—Å—Ç—Ä–æ–µ–Ω–Ω—ã–π =typing.assert_never=

* Self
–ü—É—à–∫–∞, –ø–æ—Å—Ç–æ—è–Ω–Ω–æ –µ–µ –∏—Å–ø–æ–ª—å–∑—É—é

#+begin_src mypy
from typing import Self

class Foo:
    def return_self(self) -> Self:
        ...
        return self
#+end_src

–†–∞–Ω—å—à–µ –ø—Ä–∏—Ö–æ–¥–∏–ª–æ—Å—å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å TypeVar. –¢–∞–∫–æ–π –∫–æ–¥ –µ—Å–ª–∏ —á—Ç–æ –ø–ª–æ—Ö:
#+begin_src mypy
class Bar:
    def return_self(self) -> "Bar":
        return self


class Baz(Bar):
    ...

b: Baz = Baz().return_self() # –û—à–∏–±–∫–∞
#+end_src

* Literal

#+begin_src mypy
from typing import Literal, Any, Final

def validate_simple(data: Any) -> Literal[True]:  # always returns True
    return True


type Mode = Literal['r', 'rb', 'w', 'wb']
def open_helper(file: str, mode: Mode) -> str:
    return "a"

open_helper('/some/path', 'r')      # Passes type check
open_helper('/other/path', 'typo')  # Error in type checker

mode = "wb"
open_helper('/other/path', mode)  # –¢–∞–∫ –∫ —Å–æ–∂–∞–ª–µ–Ω–∏—é —Ç–æ–∂–µ –Ω–µ —Ä–∞–±–æ—Ç–∞–µ—Ç

mode2: Literal["wb"] = "wb"
open_helper('/other/path', mode2)  # –ü—Ä–∏—Ö–æ–¥–∏—Ç—Å—è —Ç–∞–∫...

mode3: Final = "wb"
open_helper('/other/path', mode3)  # –ò–ª–∏ —Ç–∞–∫...

mode4: Final[str] = "wb"
open_helper('/other/path', mode4)  # –ê –≤–æ—Ç —Ç–∞–∫ –Ω–µ —Ä–∞–±–æ—Ç–∞–µ—Ç...

#+end_src

#+RESULTS:
: /tmp/babel-VWgyKs/mypy-xaw4C1:12: error: Argument 2 to "open_helper" has incompatible type "Literal['typo']"; expected "Literal['r', 'rb', 'w', 'wb']"  [arg-type]
: /tmp/babel-VWgyKs/mypy-xaw4C1:15: error: Argument 2 to "open_helper" has incompatible type "str"; expected "Literal['r', 'rb', 'w', 'wb']"  [arg-type]
: /tmp/babel-VWgyKs/mypy-xaw4C1:21: error: Argument 2 to "open_helper" has incompatible type "str"; expected "Literal['r', 'rb', 'w', 'wb']"  [arg-type]
: Found 3 errors in 1 file (checked 1 source file)

* Final
#+begin_src mypy
MAX_SIZE: Final = 9000
MAX_SIZE += 1  # Error reported by type checker

class Connection:
    TIMEOUT: Final[int] = 10

class FastConnector(Connection):
    TIMEOUT = 1  # Error reported by type checker
#+end_src

#+begin_src mypy
# —Ç–∞–∫ –Ω–µ –ø—Ä–∞–≤–∏–ª—å–Ω–æ –¥–µ–ª–∞—Ç—å, —Å–º–æ—Ç—Ä–∏ Literal –ø—Ä–∏–º–µ—Ä
CONSTANT: Final[str] = "VAL"

# –ü—Ä–∞–≤–∏–ª—å–Ω–æ:
CONSTANT2: Final[Literal["VAL"]] = "VAL"
CONSTANT3: Final = "VAL"
#+end_src

* ClassVar

#+begin_src mypy
from typing import ClassVar

class Starship:
    stats: ClassVar[dict[str, int]] = {} # class variable
    damage: int = 10                     # instance variable

enterprise_d = Starship()
enterprise_d.stats = {} # Error, setting class variable on instance
Starship.stats = {}     # This is OK
#+end_src

#+RESULTS:
: /tmp/babel-VWgyKs/mypy-disJsW:8: error: Cannot assign to class variable "stats" via instance  [misc]
: Found 1 error in 1 file (checked 1 source file)

* TypedDict
–î–ª—è —Ç–∏–ø–∏–∑–∞—Ü–∏–∏ dict -–∞ –æ—á–µ–Ω—å –ø–æ–ª–µ–∑–Ω–∞—è —à—Ç—É–∫–∞

#+begin_src mypy
# –õ—É—á—à–µ –≤—Å–µ–≥–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å class syntax, –Ω–æ –Ω–µ –≤—Å–µ–≥–¥–∞ —ç—Ç–æ –≤–æ–∑–º–æ–∂–Ω–æ:
class Point2D(TypedDict):
    in: int
    x-y: int

# OK, functional syntax
Point2D = TypedDict('Point2D', {'in': int, 'x-y': int})
#+end_src

–í–º–µ—Å—Ç–µ —Å Unpack –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –¥–ª—è –∞–Ω–Ω–æ—Ç–∞—Ü–∏–∏ kwargs

#+begin_src mypy
from typing import TypedDict, Unpack

class Movie(TypedDict):
    name: str
    year: int

def foo(**kwargs: Unpack[Movie]) -> None: 
    return None

foo(name=3)
#+end_src

#+RESULTS:
: /tmp/babel-VWgyKs/mypy-2gLpd4:10: error: Missing named argument "year" for "foo"  [call-arg]
: /tmp/babel-VWgyKs/mypy-2gLpd4:10: error: Argument "name" to "foo" has incompatible type "int"; expected "str"  [arg-type]
: Found 2 errors in 1 file (checked 1 source file)

** Requred NotRequired, total

#+begin_src mypy
class Point2D(TypedDict):
    x: int
    y: int
    label: NotRequired[str]

# –í—Å–µ –∞—Ä–≥—É–º–µ–Ω—Ç—ã –Ω–µ–æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ
class Point2D(TypedDict, total=False):
    x: int
    y: int

# x, y - required, label - –Ω–µ—Ç
class Point2D(TypedDict, total=False):
    x: Required[int]
    y: Required[int]
    label: str

#+end_src


–ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç –Ω–∞—Å–ª–µ–¥–æ–≤–∞–Ω–∏–µ –∏ TypeVar
#+begin_src mypy
from typing import TypedDict

class Point2D[T](TypedDict, total=False):
    x: int
    y: int
    val: T


class Point3D[T](Point2D[T]):
    z: int


assert Point3D.__required_keys__ == frozenset({"z"})
assert Point3D.__optional_keys__ == frozenset({"x", "y", "val"})
#+end_src

* Annotated

–î–æ–±–∞–≤–¥—è–µ—Ç –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ –∫ —Ç–∏–ø—É
#+begin_src mypy
from dataclasses import dataclass
from typing import Annotated

@dataclass
class ValueRange:
    lo: int
    hi: int

T2 = Annotated[T1, ValueRange(-20, 3), ctype("char")]

# –ü–æ—Ä—è–¥–æ–∫ –≤–∞–∂–µ–Ω
assert Annotated[int, ValueRange(3, 10), ctype("char")] != Annotated[
    int, ctype("char"), ValueRange(3, 10)
]

# –í–ª–æ–∂–µ–Ω–Ω–æ—Å—Ç—å —Ä–∞–∑–≤–æ—Ä–∞—á–∏–≤–∞–µ—Ç—Å—è
assert Annotated[Annotated[int, ValueRange(3, 10)], ctype("char")] == Annotated[
    int, ValueRange(3, 10), ctype("char")
]

from typing import get_type_hints

def func(x: Annotated[int, "metadata"]) -> None: pass


>> get_type_hints(func)

{'x': <class 'int'>, 'return': <class 'NoneType'>}

>> get_type_hints(func, include_extras=True)
{'x': typing.Annotated[int, 'metadata'], 'return': <class 'NoneType'>}
#+end_src

–î–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –Ω—É–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å =__metadata__=
#+begin_src python :results output
from typing import Annotated

X = Annotated[int, "very", "important", "metadata"]

assert X == Annotated[int, 'very', 'important', 'metadata']
assert X.__metadata__ == ('very', 'important', 'metadata')
#+end_src

–ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –≤ Pydantic:
#+begin_src python
from uuid import uuid4

from typing_extensions import Annotated

from pydantic import BaseModel, Field


class User(BaseModel):
    id: Annotated[str, Field(default_factory=lambda: uuid4().hex)]

# –í–º–µ—Å—Ç–æ:
class User(BaseModel):
    id: str = Field(default_factory=lambda: uuid4().hex)
#+end_src

* TypeGuard
–î–æ–ø—É—Å—Ç–∏–º —Ö–æ—Ç–∏–º —Å—É–∑–∏—Ç—å —Ç–∏–ø
#+begin_src mypy

type INT_OR_STR = str | int


def f(val: INT_OR_STR) -> str:
    # –°—É–∑–∏–ª–∏ —Ç–∏–ø
    if isinstance(val, str):
        return val
    else:
        return "a"

def f2(val: INT_OR_STR) -> str:
    # –∏–ª–∏ —Ç–∞–∫
    assert isinstance(val, str)
    return val
#+end_src


–ù–æ –º–æ–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –Ω–µ —Ç–æ–ª—å–∫–æ isinstance –∞ –ø—Ä–æ–∏–∑–≤–æ–ª—å–Ω—É—é —Ñ—É–Ω–∫—Ü–∏—é –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ —Ç–∏–ø–æ–≤

#+begin_src mypy
from typing import TypeGuard

def is_str_list(val: list[object]) -> TypeGuard[list[str]]:
    return all(isinstance(x, str) for x in val) # –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç bool

def func1(val: list[object]):
    if is_str_list(val):
        # Type of ``val`` is narrowed to ``list[str]``.
        print(" ".join(val))
    else:
        # Type of ``val`` remains as ``list[object]``.
        print("Not a list of strings!")
#+end_src

–¢—É—Ç –¥–∞–≤–∞–π—Ç–µ –æ—Ç–º–µ—Ç–∏–º, —á—Ç–æ list[str] –Ω–µ —è–≤–ª—è–µ—Ç—Å—è –ø–æ–¥—Ç–∏–ø–æ–º list[object],
–ø–æ—Ç–æ–º—É —á—Ç–æ list - invariant. –¢–∞–∫ —á—Ç–æ TypeGuard —Ä–∞–±–æ—Ç–∞–µ—Ç –Ω–µ —Ç–æ–ª—å–∫–æ —Å —Å—É–∂–µ–Ω–∏–µ–º —Ç–∏–ø–∞.

–í–æ–±—â–µ–º, –µ—Å–ª–∏ —É –≤–∞—Å —Ñ—É–Ω–∫—Ü–∏—è —Ç–∏–ø–∞ =is_some_type= –∏—Å–ø–æ–ª—å–∑—É–µ–º TypeGuard

* cast
#+begin_src mypy
def f(x: Any) -> int:
    # —è —Ç–æ—á–Ω–æ –∑–Ω–∞—é —á—Ç–æ –º–Ω–µ –ø—Ä–∏—Ö–æ–¥–∏—Ç int
    return cast(int, x) + 3
#+end_src

–î–ª—è narrowing —è –∏—Å–ø–æ–ª—å–∑—É—é assert, isinstance

* assert_type  
–ù–µ —Ä–∞–±–æ—Ç–∞–µ—Ç –≤ runtime. –£–¥–æ–±–Ω–æ –∫–æ–≥–¥–∞ –Ω–∞–¥–æ –ø—Ä–æ–≤–µ—Ä–∏—Ç—å —Ç–∏–ø
#+begin_src mypy
def complex_function(arg: object):
    # Do some complex type-narrowing logic,
    # after which we hope the inferred type will be `int`
    ...
    # Test whether the type checker correctly understands our function
    assert_type(arg, int)
#+end_src

* assert_never

–ü—Ä–∏–∫–æ–ª—å–Ω–∞—è —à—Ç—É–∫–∞, –Ω–∞–¥–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø–æ—á–∞—â–µ
#+begin_src mypy
def int_or_str(arg: int | str) -> None:
    match arg:
        case int():
            print("It's an int")
        case str():
            print("It's a str")
        case _ as unreachable:
            assert_never(unreachable)
#+end_src

* reveal_type
–ü–µ—á–∞—Ç–∞–µ—Ç —Ç–∏–ø –∫–æ–≥–¥–∞ –∑–∞–ø—É—Å–∫–∞–µ—Ç—Å—è mypy. –ù–µ –Ω–∞–¥–æ –∏–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å.
#+begin_src python
x: int = 1
reveal_type(x)  # Revealed type is "builtins.int"
#+end_src

* dataclass_transform
–•–∞–∫ mypy –¥–ª—è –¥–∞—Ç–∞–∫–ª–∞—Å—Å–æ–≤, –¥—É–º–∞—é —á—Ç–æ —ç—Ç–æ –Ω–µ —Å—Ç–æ–∏—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å
–î–æ–±–∞–≤–ª—è–µ—Ç –º–µ—Ç–æ–¥—ã, –∫–æ—Ç–æ—Ä—ã–µ –ø–æ–ª—É—á–∞—é—Ç—Å—è –≤ –¥–∞—Ç–∞–∫–ª–∞—Å—Å–∞—Ö –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏

#+begin_src python
@dataclass_transform()
def create_model[T](cls: type[T]) -> type[T]:
    ...
    return cls

@create_model
class CustomerModel:
    id: int
    name: str
#+end_src

* overload, get_overloads, clear_overloads

#+begin_src python :results output
from typing import get_overloads, overload, clear_overloads

@overload
def process(response: None) -> None:
    ...
@overload
def process(response: int) -> tuple[int, str]:
    ...
@overload
def process(response: bytes) -> str:
    ...
def process(response):
    ...  # actual implementation goes here


print(get_overloads(process))
clear_overloads()
print(get_overloads(process))
#+end_src

#+RESULTS:
: [<function process at 0x7fcb5b10a340>, <function process at 0x7fcb5ae41d00>, <function process at 0x7fcb5ae41ee0>]
: []

* final
#+begin_src mypy
from typing import final

class Base:
    @final
    def done(self) -> None:
        ...
class Sub(Base):
    def done(self) -> None:  # Error reported by type checker
        ...

@final
class Leaf:
    ...
class Other(Leaf):  # Error reported by type checker
    ...
#+end_src

* no_type_check
#+begin_src mypy
from typing import no_type_check

@no_type_check
def a(self) -> int:
    return "string"
#+end_src

#+RESULTS:
: Success: no issues found in 1 source file

* no_type_check_decorator
–ö–∞–∫–∞—è-—Ç–æ —Ñ–∏–≥–Ω—è, –ª–µ–Ω—å —Ä–∞–∑–±–∏—Ä–∞—Ç—å—Å—è, —É–∂–µ deprecated:
https://github.com/python/cpython/issues/106309

* override
–ù–∞–¥–æ –∞–∫—Ç–∏–≤–Ω–µ–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å
#+begin_src mypy
class Base:
    def log_status(self) -> None:
        ...

class Sub(Base):
    @override
    def log_status(self) -> None:  # Okay: overrides Base.log_status
        ...

    @override
    def done(self) -> None:  # Error reported by type checker
        ...
#+end_src

* type_check_only
–ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –≤ stub —Ñ–∞–π–ª–∞—Ö. –í runtime —ç—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞.

#+begin_src mypy
from typing import type_check_only

@type_check_only
class Response:  # private or not available at runtime
    code: int
    def get_header(self, name: str) -> str:
        return "a"

def fetch_response() -> Response:
    return Response()
#+end_src

#+RESULTS:
: Success: no issues found in 1 source file

* get_type_hints

–û–±—ã—á–Ω–æ —ç—Ç–æ —Ç–æ–∂–µ —Å–∞–º–æ–µ —á—Ç–æ –∏ obj.__annotations__
#+begin_src  python
from typing import get_type_hints

def func(x: int) -> str:
    return "a"

assert get_type_hints(func) == {'x': <class 'int'>, 'return': <class 'str'>}

class A:
    y: int

assert get_type_hints(A) == {'y': <class 'int'>}
#+end_src

–ï—Å—Ç—å –µ—â–µ inspect.get_annotations https://github.com/python/cpython/issues/102405

#+begin_src python
import inspect, typing

class A:
    age: int

class B(A):
    name: str

print(inspect.get_annotations(B))  # {'name': <class 'str'>}
print(typing.get_type_hints(B))  # {'age': <class 'int'>, 'name': <class 'str'>}
#+end_src

* get_origin

#+begin_src python
assert get_origin(str) is None
assert get_origin(Dict[str, int]) is dict
assert get_origin(Union[int, str]) is Union
P = ParamSpec('P')
assert get_origin(P.args) is P
assert get_origin(P.kwargs) is P
#+end_src

* get_args
#+begin_src python
assert get_args(int) == ()
assert get_args(Dict[int, str]) == (int, str)
assert get_args(Union[int, str]) == (int, str)
#+end_src

* is_typeddict
#+begin_src python
class Film(TypedDict):
    title: str
    year: int

assert is_typeddict(Film)
assert not is_typeddict(list | str)

# TypedDict is a factory for creating typed dicts,
# not a typed dict itself
assert not is_typeddict(TypedDict)
#+end_src

* ForwardRef
–ß–µ—Ä–Ω–∞—è –º–∞–≥–∏—è, –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è —Ç–∏–ø–æ–≤ –≤ –≤–∏–¥–µ —Å—Ç—Ä–æ–∫

For example, List["SomeClass"] is implicitly transformed into List[ForwardRef("SomeClass")]. ForwardRef should not be instantiated by a user, but may be used by introspection tools.

* TYPE_CHECKING
#+begin_src mypy

if TYPE_CHECKING:
    import expensive_mod

def fun(arg: 'expensive_mod.SomeType') -> None:
    local_var: expensive_mod.AnotherType = other_fun()
#+end_src
